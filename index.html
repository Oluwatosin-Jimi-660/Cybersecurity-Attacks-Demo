<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SQL Injection & XSS Classroom Demo (Safe Visualizer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-b from-gray-50 to-white text-gray-900">
  <div id="root"></div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel Standalone for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Your app (JSX compiled in the browser) -->
  <script type="text/babel">
    const { useState, useMemo } = React;

    function Card({ title, children }) {
      return (
        <div className="rounded-2xl shadow-lg border border-gray-200 bg-white p-5">
          <div className="text-lg font-semibold mb-3">{title}</div>
          <div className="text-sm text-gray-700 space-y-3">{children}</div>
        </div>
      );
    }

    function Pill({ children }) {
      return (
        <span className="inline-block rounded-full bg-gray-100 px-3 py-1 text-xs font-medium text-gray-700">
          {children}
        </span>
      );
    }

    function SectionTitle({ children }) {
      return <h2 className="text-xl font-bold tracking-tight mb-3">{children}</h2>;
    }

    function CodeBlock({ code }) {
      return (
        <pre className="text-xs overflow-auto rounded-xl bg-gray-900 text-gray-100 p-4 leading-relaxed">
          <code>{code}</code>
        </pre>
      );
    }

    function InlineCode({ children }) {
      return (
        <code className="rounded bg-gray-100 px-1.5 py-0.5 text-[0.8rem] font-mono text-gray-800">
          {children}
        </code>
      );
    }

    // --- Utility helpers ---
    const escapeHTML = (s) =>
      String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\\"/g, "&quot;")
        .replace(/'/g, "&#39;");

    const highlightSQL = (sql) => {
      const escaped = escapeHTML(sql);
      return escaped.replace(/\b(SELECT|FROM|WHERE|AND|OR|INSERT|INTO|VALUES|UPDATE|SET|DELETE)\b/gi, (m) => {
        return `<span class="text-indigo-300">${m}</span>`;
      });
    };

    // --- Fake user db for the demo ---
    const USERS = [
      { username: "alice", password: "password123" },
      { username: "bob", password: "winter2024" },
    ];

    const looksLikeTautology = (u, p) => /'\\s*OR\\s*'1'='1/i.test(u) || /'\\s*OR\\s*'1'='1/i.test(p);
    const hasUnbalancedQuote = (s) => (String(s).match(/'/g) || []).length % 2 === 1;

    function SQLiDemo() {
      const [username, setUsername] = useState("");
      const [password, setPassword] = useState("");
      const [usePrepared, setUsePrepared] = useState(false);

      const naiveSQL = useMemo(() => {
        return `SELECT * FROM users WHERE username = '${username}' AND password = '${password}';`;
      }, [username, password]);

      const preparedSQL = `SELECT * FROM users WHERE username = ? AND password = ?;`;
      const preparedParams = [username, password];

      const result = useMemo(() => {
        if (usePrepared) {
          const found = USERS.find((u) => u.username === username && u.password === password);
          if (found) return { status: "success", http: 200, detail: "Authenticated (parameterized query)." };
          return { status: "fail", http: 401, detail: "Invalid credentials (no injection possible)." };
        }

        if (hasUnbalancedQuote(username) || hasUnbalancedQuote(password)) {
          return { status: "error", http: 500, detail: "SQL syntax error: unterminated string near quote. (Simulated)" };
        }

        if (looksLikeTautology(username, password)) {
          return {
            status: "success",
            http: 200,
            detail: "Authenticated because WHERE clause became a tautology (e.g., ' OR '1'='1). This is a SQL injection effect.",
          };
        }

        const found = USERS.find((u) => u.username === username && u.password === password);
        if (found) return { status: "success", http: 200, detail: "Authenticated (but query was vulnerable)." };
        return { status: "fail", http: 401, detail: "Invalid credentials." };
      }, [username, password, usePrepared]);

      const prefillLegit = () => { setUsername("alice"); setPassword("password123"); };
      const prefillInjection = () => { setUsername("' OR '1'='1"); setPassword("anything"); };

      return (
        <div className="space-y-4">
          <SectionTitle>SQL Injection (visualized)</SectionTitle>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card title="Login form (student input)">
              <div className="space-y-3">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  <label className="text-sm">
                    <div className="mb-1 font-medium">Username</div>
                    <input
                      className="w-full rounded-xl border px-3 py-2"
                      placeholder="e.g. alice or ' OR '1'='1"
                      value={username}
                      onChange={(e) => setUsername(e.target.value)}
                    />
                  </label>
                  <label className="text-sm">
                    <div className="mb-1 font-medium">Password</div>
                    <input
                      className="w-full rounded-xl border px-3 py-2"
                      type="text"
                      placeholder="try a password or anything"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                    />
                  </label>
                </div>

                <div className="flex flex-wrap items-center gap-2 pt-1">
                  <button onClick={prefillLegit} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Prefill valid</button>
                  <button onClick={prefillInjection} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Prefill injection</button>
                  <button onClick={() => { setUsername(""); setPassword(""); }} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Reset</button>
                  <div className="ml-auto flex items-center gap-2">
                    <input id="prepared" type="checkbox" checked={usePrepared} onChange={(e) => setUsePrepared(e.target.checked)} />
                    <label htmlFor="prepared" className="text-sm">Use prepared statements (safe)</label>
                  </div>
                </div>
              </div>
            </Card>

            <Card title={usePrepared ? "Server (SAFE)" : "Server (VULNERABLE)"}>
              {usePrepared ? (
                <div className="space-y-2">
                  <div>
                    <div className="font-medium mb-1">Parameterized query</div>
                    <CodeBlock code={`${preparedSQL}\nParams: ${JSON.stringify(preparedParams)}`} />
                  </div>
                  <div className="text-green-700 font-medium">{result.detail}</div>
                  <div>
                    <div className="font-medium mb-1">Why it's safe</div>
                    <ul className="list-disc pl-5 space-y-1">
                      <li>Query and data are sent separately; the database never parses user input as SQL.</li>
                      <li>Even payloads like <InlineCode>' OR '1'='1</InlineCode> are treated as literal strings.</li>
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="space-y-2">
                  <div>
                    <div className="font-medium mb-1">Concatenated SQL (danger)</div>
                    <div
                      className="text-xs overflow-auto rounded-xl bg-gray-900 text-gray-100 p-4 leading-relaxed"
                      dangerouslySetInnerHTML={{ __html: highlightSQL(naiveSQL) }}
                    />
                  </div>
                  <div className={
                    result.status === "success" ? "text-green-700 font-medium" :
                    result.status === "fail" ? "text-amber-700 font-medium" :
                    "text-red-700 font-medium"
                  }>
                    {result.detail}
                  </div>
                  <div className="text-xs text-gray-600">
                    <Pill>HTTP {result.http}</Pill>
                    {result.status === "error" && <span className="ml-2">(500 – simulated syntax error leak)</span>}
                  </div>
                  <div>
                    <div className="font-medium mb-1">Mitigations</div>
                    <ul className="list-disc pl-5 space-y-1">
                      <li>Use parameterized queries (<InlineCode>?</InlineCode> placeholders) or ORM bindings.</li>
                      <li>Apply least-privilege DB accounts; hide detailed errors from users.</li>
                      <li>Validate inputs server-side and log suspicious patterns.</li>
                    </ul>
                  </div>
                </div>
              )}
            </Card>
          </div>

          <Card title="Teacher guide (SQLi quick demo)">
            <ol className="list-decimal pl-6 space-y-1 text-sm">
              <li>Click <b>Prefill injection</b>. Observe how the vulnerable server authenticates due to a tautology.</li>
              <li>Toggle <b>Use prepared statements</b> and try again to see the attack fail safely.</li>
              <li>Discuss why leaking <InlineCode>500</InlineCode> errors can disclose internals; show a quote mismatch to trigger one.</li>
            </ol>
          </Card>
        </div>
      );
    }

    function XSSDemo() {
      const [name, setName] = useState("");
      const [comment, setComment] = useState("");
      const [runUntrusted, setRunUntrusted] = useState(false);

      const prefillNice = () => { setName("Charlie"); setComment("Great lesson! Thanks for the demo."); };
      const prefillXSS = () => {
        setName("<b>Visitor</b>");
        setComment("<img src=x onerror=alert('XSS')> Hello!");
      };

      const safeRendered = useMemo(() => ({
        name: escapeHTML(name),
        comment: escapeHTML(comment),
      }), [name, comment]);

      const unsafeRendered = useMemo(() => ({ name, comment }), [name, comment]);

      return (
        <div className="space-y-4">
          <SectionTitle>Cross-Site Scripting (XSS)</SectionTitle>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card title="Comment form (student input)">
              <div className="space-y-3">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  <label className="text-sm">
                    <div className="mb-1 font-medium">Display name</div>
                    <input
                      className="w-full rounded-xl border px-3 py-2"
                      placeholder="e.g. Alex or <b>Alex</b>"
                      value={name}
                      onChange={(e) => setName(e.target.value)}
                    />
                  </label>
                  <label className="text-sm md:col-span-1">
                    <div className="mb-1 font-medium">Comment</div>
                    <input
                      className="w-full rounded-xl border px-3 py-2"
                      placeholder="type a message or try an HTML tag"
                      value={comment}
                      onChange={(e) => setComment(e.target.value)}
                    />
                  </label>
                </div>
                <div className="flex flex-wrap items-center gap-2 pt-1">
                  <button onClick={prefillNice} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Prefill friendly</button>
                  <button onClick={prefillXSS} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Prefill XSS</button>
                  <button onClick={() => { setName(""); setComment(""); }} className="rounded-2xl border px-3 py-1 text-sm hover:bg-gray-50">Reset</button>
                  <div className="ml-auto flex items-center gap-2">
                    <input id="runHTML" type="checkbox" checked={runUntrusted} onChange={(e) => setRunUntrusted(e.target.checked)} />
                    <label htmlFor="runHTML" className="text-sm">Run untrusted HTML (unsafe)</label>
                  </div>
                </div>
              </div>
            </Card>

            <Card title={runUntrusted ? "Renderer (VULNERABLE)" : "Renderer (SAFE)"}>
              {runUntrusted ? (
                <div className="space-y-3">
                  <div className="text-sm">Below we render with <InlineCode>dangerouslySetInnerHTML</InlineCode> (don’t do this with user input):</div>
                  <div className="rounded-xl border p-3">
                    <div className="text-xs text-gray-500">Name:</div>
                    <div dangerouslySetInnerHTML={{ __html: unsafeRendered.name || "<i>(empty)</i>" }} />
                    <div className="text-xs text-gray-500 mt-2">Comment:</div>
                    <div dangerouslySetInnerHTML={{ __html: unsafeRendered.comment || "<i>(empty)</i>" }} />
                  </div>
                  <div className="text-red-700 font-medium">If a script runs here, that's a stored/reflected XSS effect.</div>
                  <div>
                    <div className="font-medium mb-1">Mitigations</div>
                    <ul className="list-disc pl-5 space-y-1">
                      <li>Escape output by context (HTML/attr/JS/URL) or use a trusted templating engine.</li>
                      <li>Sanitize HTML with a vetted library (e.g., DOMPurify) if rich text is required.</li>
                      <li>Enable CSP (Content-Security-Policy) to reduce impact.</li>
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="space-y-3">
                  <div className="text-sm">Below we escape user input before rendering (safe path):</div>
                  <div className="rounded-xl border p-3">
                    <div className="text-xs text-gray-500">Name:</div>
                    <div className="font-medium" dangerouslySetInnerHTML={{ __html: safeRendered.name || "<i>(empty)</i>" }} />
                    <div className="text-xs text-gray-500 mt-2">Comment:</div>
                    <div dangerouslySetInnerHTML={{ __html: safeRendered.comment || "<i>(empty)</i>" }} />
                  </div>
                  <div className="text-green-700 font-medium">Unsafe tags are rendered inert; scripts do not run.</div>
                </div>
              )}
            </Card>
          </div>

          <Card title="Teacher guide (XSS quick demo)">
            <ol className="list-decimal pl-6 space-y-1 text-sm">
              <li>Click <b>Prefill XSS</b> to load a classic demo payload in the form.</li>
              <li>With <b>Run untrusted HTML</b> <i>off</i>, show how escaping neutralizes it.</li>
              <li>Toggle <b>Run untrusted HTML</b> <i>on</i> (unsafe) to illustrate script execution risk.</li>
            </ol>
          </Card>
        </div>
      );
    }

    function SecurityDemos() {
      const [tab, setTab] = useState("sqli");
      return (
        <div className="min-h-screen">
          <div className="mx-auto max-w-6xl px-4 py-8">
            <header className="mb-6">
              <h1 className="text-2xl md:text-3xl font-bold tracking-tight">Classroom Demos: SQL Injection & XSS (Safe Visualizer)</h1>
              <p className="text-sm text-gray-600 mt-2 max-w-3xl">
                This self-contained page <b>simulates</b> insecure vs. secure handling of user input for two common web risks.
                It never connects to a real database and only executes scripts if you intentionally enable the unsafe toggle.
                Use it for teaching—not for attacking systems. 🧑‍🏫
              </p>
              <div className="mt-3 flex flex-wrap items-center gap-2">
                <Pill>Client-side simulation</Pill><Pill>No real DB</Pill><Pill>Safe defaults</Pill>
              </div>
            </header>

            <nav className="flex gap-2 mb-6">
              <button onClick={() => setTab("sqli")} className={`rounded-2xl px-4 py-2 text-sm border ${tab === "sqli" ? "bg-gray-900 text-white" : "bg-white hover:bg-gray-50"}`}>
                SQL Injection
              </button>
              <button onClick={() => setTab("xss")} className={`rounded-2xl px-4 py-2 text-sm border ${tab === "xss" ? "bg-gray-900 text-white" : "bg-white hover:bg-gray-50"}`}>
                XSS
              </button>
            </nav>

            <main className="space-y-6">
              {tab === "sqli" ? <SQLiDemo /> : <XSSDemo />}

              <Card title="Instructor notes & safety">
                <ul className="list-disc pl-5 space-y-1 text-sm">
                  <li>Keep this demo local or in a sandboxed environment. Do not collect real user data.</li>
                  <li>Use the <b>SAFE</b> versions to emphasize proper mitigations (parameterized queries, output encoding, sanitization, CSP).</li>
                  <li>Discuss defense-in-depth: input validation, least-privilege, stored procedure parameterization, secure error handling.</li>
                  <li>Never test techniques on systems without explicit permission. This demo is intentionally scoped to the page only.</li>
                </ul>
              </Card>
            </main>

            <footer className="text-xs text-gray-500 mt-8">
              © <script>document.write(new Date().getFullYear())</script> Classroom demo. Purpose: education & awareness.
            </footer>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<SecurityDemos />);
  </script>
</body>
</html>
